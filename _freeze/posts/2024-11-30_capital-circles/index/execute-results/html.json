{
  "hash": "7e6602e4e47b96fbd8ed1338a2c983c4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Capital Circles\"\ndate: '2024-11-30'\nexecute:\n  freeze: true\n  message: false\n  warning: false\ncode-fold: false\nengine: knitr\nfilters:\n  - line-highlight\n---\n\n\n\n\n\nI really enjoyed seeing other's #30DayMapChallenge posts, and particularly those of Ansgar Wolsing. I spent a while thinking about this glorious post\n\n<iframe src=\"https://www.linkedin.com/embed/feed/update/urn:li:share:7264973254291869696\" height=\"834\" width=\"504\" frameborder=\"0\" allowfullscreen=\"\" title=\"Embedded post\"></iframe>\n\nAnd had the idea of creating a map of circles centered around cities with the radius being the shortest distance to another city above a certain population threshold. So let's throw something together.\n\nFirst I'll load my packages, and Ansgar introduced me to `{giscoR}` for obtaining shapefiles. Previously, I've used `{rnaturalearthdata}` but think I might change the default going forwards.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"tidyverse\")\nlibrary(\"maps\")\nlibrary(\"sf\")\nlibrary(\"giscoR\")\nlibrary(\"countrycode\")\n\ncountries_sf <- gisco_get_countries() %>% \n  as_tibble() %>% \n  st_as_sf()\n\n# Manually remove duplicate San Jose and Nicosia\ncities_clean <- world.cities %>% \n  as_tibble() %>% \n  # filter(capital == 1) %>% \n  filter(!(name == \"San Jose\" & lat == 10.97),\n         !(name == \"Nicosia\" & long == 33.37)) %>% \n  mutate(iso_3c = countrycode(country.etc, \"country.name\", \"iso3c\")) %>% \n  drop_na() %>% \n  st_as_sf(coords = c(\"long\", \"lat\"), crs = 4326)\n```\n:::\n\n\n\nLet's only look at cities with a population of at least 1 million\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncities_of_interest <- cities_clean %>% \n  filter(pop >= 1000000)\n```\n:::\n\n\n\nHere's a neat little function that finds the max and min distance to each row in the data\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_max_min_point_to_row <- function(data, row_n){\n  target_row <- slice(data, row_n)\n  \n  all_others <- slice(data, setdiff(1:nrow(data), row_n))\n  \n  all_distances <- st_distance(st_as_sfc(target_row), st_as_sfc(all_others))\n  \n  min_iso_3c <- slice(all_others, which.min(as.numeric(all_distances))) %>% \n    pull(iso_3c)\n  \n  max_iso_3c <- slice(all_others, which.max(as.numeric(all_distances))) %>% \n    pull(iso_3c)\n  \n  target_row %>% \n    mutate(min_iso_3c = min_iso_3c,\n           min_distance = min(all_distances),\n           max_iso_3c = max_iso_3c,\n           max_distance = max(all_distances))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncities_of_interest_distances <- 1:nrow(cities_of_interest) %>% \n  map_dfr(~add_max_min_point_to_row(cities_of_interest, .x))\n```\n:::\n\n\n\nAnd map!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngg_city_circles <- ggplot() +\n  geom_sf(data = cities_of_interest_distances %>% \n            mutate(geometry = st_buffer(geometry, dist = min_distance, nQuadSegs = 100)) %>% \n            st_wrap_dateline() ,\n          fill = \"#663399\",\n          linewidth = 0) + \n  geom_sf(data = countries_sf %>% \n            filter(!NAME_ENGL %in% c(\"Antarctica\")) %>%\n            mutate(area = as.numeric(st_area(geometry))) %>% \n            filter(area >= 1E11),\n          fill = \"transparent\",\n          colour = colorspace::lighten(\"lightblue\", amount = 0.2)) + \n  labs(title = \"Closest cities with populations of least 1 million\") +\n  coord_sf(crs = \"+proj=robin\") +\n  theme_void() +\n  theme(panel.background = element_rect(fill = \"lightblue\")) +\n  NULL\n\nggsave(quarto_here(\"gg_city_circles.png\"),\n       gg_city_circles,\n       width = 2 * 4,\n       height = 2 * 2.37)\n```\n:::\n\n\n\n![](gg_city_circles.png)\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}