{
  "hash": "d1dab8cff0f7c12e4f8860db4f859c66",
  "result": {
    "markdown": "---\ntitle: \"Shiny modules to reduce duplication in apps\"\ndescription: \"Help reduce the duplication of code in {shiny} apps through the use of modules\"\ndate: '2019-07-09'\ncategories:\n  - shiny\ntags:\n  - modules\ncode-fold: false\nimage: /posts/2019-07-09-shiny-modules-to-reduce-duplication-in-apps/shiny-app-wireframe.png\n---\n\n\nShiny apps are awesome, with a bit of training you can build fairly impressive interactive web apps. But at some point, the subject of \"shiny modules\" will rear its head.\n\nWhen I started learning modules, I found most of the existing [articles](http://shiny.rstudio.com/articles/modules.html) focus on the technical-side of things and don't focus on the **benefits of using modules** - they can significantly simplify and improve your apps.\n\nI'm going to put together a few different tutorials on real-world Shiny apps and how modules can be used to improve them. As these tutorials develop I'll link to them below.\n\nBut for now, we're going to build this Shiny app:\n\n<div class=\"row\">\n\n<div class=\"col-sm-5\">\n<center>\n<img src='shiny-app-wireframe.png' alt='Wireframe for shiny app' width='300px'></img>\n</center>\n</div>\n\n<div class=\"col-sm-7\">\n\n- The shiny app displays data from the `WDI` package\n\n- Each \"page\" of the Shiny app details a different \"development indicator\" from the `WDI` package\n\n- Users select a country of interest from a pull-down menu\n\n- The chart, text and table underneath the pull-down menu all update when a country is selected\n\n- The charts, text and tables are **the same on each page** except for two variables; the selected country and the indicator detailed on that page.\n</div>\n</div>\n\n### How to use this tutorial\n\nIt's often useful to skim read through a tutorial before attempting to run the code on your own machine. If you do want to follow along with the code, you will need to install the `{usethis}` package before starting.\n\nThis tutorial is split into \n\n- Shiny app without modules\n\n- Shiny app \n\n\n### Shiny app without modules\n\nThe module-free version of the Shiny app can be downloaded onto your machine by running this code:\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_course(\"https://github.com/charliejhadley/training_shiny-module/raw/master/wdi_indicators_modules/01_without-modules.zip\")\n```\n:::\n\nOnce the RStudio project has opened,  let's take a look at the structure of the `ui.R` file in the app:\n\n::: {.cell}\n\n```{.r .cell-code}\ncountries_list <- c(...)\n\nnavbarPage(\n  \"WDI\",\n  tabPanel(\n    \"Internet\",\n    fluidPage(\n      selectInput(\"internet_country\",\n                  choices = countries_list),\n      ...\n    )\n  ),\n  tabPanel(\n    \"Bank branches\",\n    fluidPage(\n      selectInput(\"bank_branches_country\",\n                  choices = countries_list),\n      ...\n    )\n  ),\n  ...\n)\n```\n:::\n\nWe're essentailly duplicating the same `selectInput()` in each of our `tabPanel()`s. If there were *many* controls being repeated we could make an argument for using modules from this file alone.\n\nLet's take a look at the `server.R` file of this app:\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction(input, output, session){\n  \n  output$internet_timeline <- renderPlot({\n    \n    wdi_data %>%\n      gg_wdi_indicator_timeline(input$internet_country,\n                                ...)\n    \n  })\n  \n  output$internet_comparison_table <- renderUI({\n    \n    ranking_table <- wdi_data %>%\n    filter(country == input$internet_country) %>%\n    \n    ranking_table %>%\n        datatable()\n        \n  })\n  \n  output$bank_branches_timeline <- renderPlot({\n    \n    wdi_data %>%\n      gg_wdi_indicator_timeline(input$bank_branches_country,\n                              ...)\n    \n  })\n  \n  output$bank_branches_comparison_table <- renderUI({\n    \n    ranking_table <- wdi_data %>%\n    filter(country == input$bank_branches_country) %>%\n    ...\n    \n    ranking_table %>%\n        datatable(...)\n        \n  })\n  \n}\n```\n:::\n\nThere's a lot of duplication in this file. If we wanted to add a new tab about the number of secondary school students, we would have to add all of the following:\n\n::: {.cell}\n\n```{.r .cell-code}\n## ui.R\ntabPanel(\n  \"Secondary schools\",\n  fluidPage(\n    selectInput(\"secondary_schools_country\",\n                choices = countries_list),\n    ...\n  )\n)\n## server.R\noutput$secondary_schools_timeline <- renderPlot({\n  \n  wdi_data %>%\n    gg_wdi_indicator_timeline(input$secondary_schools_country,\n                              ...)\n  \n})\n\noutput$secondary_schools_comparison_table <- renderUI({\n  \n  ranking_table <- wdi_data %>%\n    filter(country == input$secondary_schools_country) %>%\n    ...\n  \n  ranking_table %>%\n    datatable(...)\n  \n})\n```\n:::\n\nLet's breakdown the advantages to re-writing this app to use modules.\n\n#### What would be the benefits of switching to use modules?\n\n\n- Without modules, if we wanted to change the look of the \"comparison tables\" we would need to do that X times - once for each `output$*_comparison_table` object.<br>\nModules therefore help reduce transcription or copy/paste errors.\n\n- Modules will allow us to change the \n\n- Modules will reduce script file length, making the code easier to read and understand\n\n- Currently, if we wanted to change \n\nIf we needed to add another tab to our \n\nEach time we add a new tab to our shiny app, we'll need to create a new pair of `render*()` functions and corresponding inputs in the `ui.R` file. \n\nBy re-designing our app to use modules, we'll benefit from the following:\n\n- Reduced script file lenght, improving readability\n- Simpler feature updates, changing the module code will update all pages at once.\n\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}